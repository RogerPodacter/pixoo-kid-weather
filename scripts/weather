#!/usr/bin/env ruby
require_relative "../config/environment"
require_relative "../lib/pixoo_device"
require_relative "../lib/location"

class WeatherDisplay
  PREVIEW_PATH = "/tmp/pixoo_weather_preview.png"

  def self.lat
    Location.lat
  end

  def self.lon
    Location.lon
  end

  def self.countdown_start
    ENV["WEATHER_COUNTDOWN_START"]
  end

  def self.countdown_end
    ENV["WEATHER_COUNTDOWN_END"]
  end

  def self.fireworks_duration
    ENV.fetch("WEATHER_FIREWORKS_DURATION", "2m")
  end

  def self.resolve_device
    PixooDevice.resolve(ENV.fetch("WEATHER_DEVICE", nil))
  rescue PixooDevice::AmbiguousDevice => e
    abort "WEATHER_DEVICE not set.\n#{e.message}\nRun `scripts/weather --list` to see devices."
  end

  WEATHER_CODES = {
    0 => "clear",
    1 => "mostly clear",
    2 => "partly cloudy",
    3 => "overcast",
    45 => "foggy",
    48 => "foggy",
    51 => "light drizzle",
    53 => "drizzle",
    55 => "heavy drizzle",
    56 => "freezing drizzle",
    57 => "freezing drizzle",
    61 => "light rain",
    63 => "rain",
    65 => "heavy rain",
    66 => "freezing rain",
    67 => "freezing rain",
    71 => "light snow",
    73 => "snow",
    75 => "heavy snow",
    77 => "snow grains",
    80 => "rain showers",
    81 => "rain showers",
    82 => "heavy showers",
    85 => "snow showers",
    86 => "heavy snow showers",
    95 => "thunderstorm",
    96 => "thunderstorm + hail",
    99 => "severe thunderstorm"
  }

  def initialize(preview: false)
    @preview = preview
    @weather = nil
    @weather_fetched_at = nil
    @last_state = {}
    @firework_frame = 0

    if @preview
      log "Preview mode: output to #{PREVIEW_PATH}"
    else
      @pixoo = self.class.resolve_device
      log "Weather display started (#{@pixoo.ip})"
      log "Ctrl+C to stop."
    end
  end

  def run
    loop do
      refresh_weather_if_needed
      update_display
      sleep 1
    rescue => e
      log "Error: #{e.message}"
      sleep 5
    end
  end

  private

  def log(msg)
    puts "[#{Time.current.strftime('%H:%M:%S')}] #{msg}"
  end

  def refresh_weather_if_needed
    # Refresh weather every 60 seconds
    if @weather.nil? || @weather_fetched_at.nil? || Time.current - @weather_fetched_at > 60
      old_weather = @weather
      @weather = fetch_weather
      @weather_fetched_at = Time.current

      if old_weather.nil? && @weather[:timezone]
        Time.zone = @weather[:timezone]
        log "Timezone: #{@weather[:timezone]}"
      end

      code_desc = WEATHER_CODES[@weather[:code]] || "unknown"
      log "Weather: #{@weather[:feels_like]}Â° feels like, #{@weather[:wind]}mph wind, #{code_desc}"

      if old_weather && old_weather[:feels_like] != @weather[:feels_like]
        log "  Temperature changed: #{old_weather[:feels_like]}Â° â†’ #{@weather[:feels_like]}Â°"
      end
    end
  end

  def fetch_weather
    uri = URI("https://api.open-meteo.com/v1/forecast")
    uri.query = URI.encode_www_form(
      latitude: self.class.lat,
      longitude: self.class.lon,
      current: "temperature_2m,apparent_temperature,weather_code,wind_speed_10m,precipitation,snowfall,is_day,relative_humidity_2m",
      hourly: "precipitation_probability",
      forecast_hours: 3,
      temperature_unit: "fahrenheit",
      wind_speed_unit: "mph",
      timezone: "auto"
    )

    response = Net::HTTP.get(uri)
    data = JSON.parse(response)

    precip_probs = data.dig("hourly", "precipitation_probability") || []
    max_precip_prob = precip_probs.first(3).max || 0

    {
      temp: data.dig("current", "temperature_2m")&.round,
      feels_like: data.dig("current", "apparent_temperature")&.round,
      code: data.dig("current", "weather_code") || 0,
      wind: (data.dig("current", "wind_speed_10m") || 0).round,
      precip: data.dig("current", "precipitation") || 0,
      snow: data.dig("current", "snowfall") || 0,
      is_day: data.dig("current", "is_day") == 1,
      precip_prob: max_precip_prob,
      humidity: data.dig("current", "relative_humidity_2m")&.round,
      timezone: data["timezone"]
    }
  end

  def update_display
    img = Pixoo::ImageBuffer.new(64, speed: 100)

    sky, _ = sky_emoji_for(@weather)
    comfort = comfort_emoji_for(@weather)
    clothing = clothing_for_temp(@weather[:feels_like])
    progress = countdown_progress

    # Build current state
    current_state = {
      sky: sky,
      comfort: comfort,
      clothing: clothing.join,
      countdown: progress ? (progress * 100).round : nil
    }

    # Log changes
    if @last_state != current_state
      changes = []
      changes << "sky=#{sky}" if @last_state[:sky] != sky
      changes << "comfort=#{comfort}" if @last_state[:comfort] != comfort
      changes << "clothing=#{clothing.join}" if @last_state[:clothing] != clothing.join
      if @last_state[:countdown] != current_state[:countdown]
        changes << "countdown=#{progress ? "#{(progress * 100).round}%" : 'off'}"
      end

      if @last_state.empty?
        log "Display initialized: sky=#{sky} comfort=#{comfort} clothing=#{clothing.join}"
      else
        log "Display changed: #{changes.join(', ')}"
      end

      @last_state = current_state
    end

    # Draw countdown background first (if active), then everything on top
    draw_countdown_background(img)
    draw_sky_emoji(img)
    draw_comfort_emoji(img)
    draw_clothing(img)
    draw_parent_info(img)

    if @preview
      save_preview(img)
    else
      @pixoo.send_animation([img])
    end
  end

  def save_preview(img)
    png = ChunkyPNG::Image.new(64, 64, ChunkyPNG::Color::BLACK)

    64.times do |y|
      64.times do |x|
        r, g, b = img.get_pixel(y, x)
        png[x, y] = ChunkyPNG::Color.rgb(r, g, b)
      end
    end

    png.save(PREVIEW_PATH)
  end

  # --- Weather codes ---
  SNOW_CODES = [71, 73, 75, 77, 85, 86]
  RAIN_CODES = [51, 53, 55, 56, 57, 61, 63, 65, 66, 67, 80, 81, 82]
  STORM_CODES = [95, 96, 99]
  CLOUDY_CODES = [2, 3, 45, 48]

  CLOTHING = {
    freezing: %w[ðŸ§¥ ðŸ§¤ ðŸ§£],
    cold:     %w[ðŸ§¥ ðŸ§£],
    cool:     %w[ðŸ§¥],
    warm:     %w[ðŸ‘•],
    hot:      %w[ðŸ‘• ðŸ©³ ðŸ˜Ž]
  }

  def draw_sky_emoji(img)
    emoji, show_timer = sky_emoji_for(@weather)
    draw_emoji(img, emoji, 2, 2, 20)
    draw_emoji(img, "â³", 18, 12, 10) if show_timer
  end

  def sky_emoji_for(weather)
    code = weather[:code]
    snow = weather[:snow]
    precip = weather[:precip]
    precip_prob = weather[:precip_prob]
    is_day = weather[:is_day]

    return ["â›ˆï¸", false] if STORM_CODES.include?(code)
    return ["â„ï¸", false] if snow > 0 || SNOW_CODES.include?(code)
    return ["â„ï¸", true] if precip_prob > 50 && weather[:feels_like] && weather[:feels_like] < 35
    return ["â˜”", false] if precip > 0 || RAIN_CODES.include?(code)
    return ["â˜”", true] if precip_prob > 50
    return ["â˜ï¸", false] if CLOUDY_CODES.include?(code)
    is_day ? ["â˜€ï¸", false] : ["ðŸŒ™", false]
  end

  def draw_comfort_emoji(img)
    emoji = comfort_emoji_for(@weather)
    draw_emoji(img, emoji, 44, 2, 18)
  end

  def comfort_emoji_for(weather)
    wind = weather[:wind]
    feels = weather[:feels_like] || 50
    return "ðŸŒ¬ï¸" if wind >= 18 && feels <= 55
    return "ðŸ¥¶" if feels < 32
    return "ðŸ¥µ" if feels >= 85
    "ðŸ˜Š"
  end

  def draw_clothing(img)
    clothing = clothing_for_temp(@weather[:feels_like])
    emoji_size = 28
    spacing = 2
    total_width = (clothing.length * emoji_size) + ((clothing.length - 1) * spacing)
    start_x = (64 - total_width) / 2
    y = 24

    clothing.each_with_index do |emoji, i|
      x = start_x + (i * (emoji_size + spacing))
      draw_emoji(img, emoji, x, y, emoji_size)
    end
  end

  def clothing_for_temp(feels_like)
    return CLOTHING[:freezing] if feels_like.nil? || feels_like < 20
    return CLOTHING[:cold] if feels_like < 40
    return CLOTHING[:cool] if feels_like < 60
    return CLOTHING[:warm] if feels_like < 75
    CLOTHING[:hot]
  end

  # --- Mini font for parent info ---
  MINI_FONT = {
    "0" => [0x6, 0x9, 0x9, 0x9, 0x6],
    "1" => [0x2, 0x6, 0x2, 0x2, 0x7],
    "2" => [0x6, 0x1, 0x2, 0x4, 0x7],
    "3" => [0x6, 0x1, 0x2, 0x1, 0x6],
    "4" => [0x9, 0x9, 0x7, 0x1, 0x1],
    "5" => [0x7, 0x4, 0x6, 0x1, 0x6],
    "6" => [0x6, 0x8, 0xE, 0x9, 0x6],
    "7" => [0x7, 0x1, 0x2, 0x2, 0x2],
    "8" => [0x6, 0x9, 0x6, 0x9, 0x6],
    "9" => [0x6, 0x9, 0x7, 0x1, 0x6],
    "Â°" => [0x2, 0x5, 0x2, 0x0, 0x0],
    " " => [0x0, 0x0, 0x0, 0x0, 0x0],
    "-" => [0x0, 0x0, 0x7, 0x0, 0x0],
    ":" => [0x0, 0x4, 0x0, 0x4, 0x0],
    "m" => [0x0, 0x0, 0xA, 0xF, 0x9],
    "p" => [0x0, 0xE, 0x9, 0xE, 0x8],
    "h" => [0x8, 0x8, 0xE, 0x9, 0x9],
    "a" => [0x0, 0x6, 0x1, 0x7, 0x9],
    "M" => [0x9, 0xF, 0xF, 0x9, 0x9],
    "T" => [0x7, 0x2, 0x2, 0x2, 0x2],
    "W" => [0x9, 0x9, 0xF, 0xF, 0x9],
    "F" => [0x7, 0x4, 0x6, 0x4, 0x4],
    "S" => [0x7, 0x4, 0x6, 0x1, 0x6],
    "u" => [0x0, 0x0, 0x9, 0x9, 0x7],
    "e" => [0x0, 0x6, 0xF, 0x8, 0x6],
    "o" => [0x0, 0x0, 0x6, 0x9, 0x6],
    "r" => [0x0, 0x0, 0xB, 0xC, 0x8],
    "i" => [0x2, 0x0, 0x2, 0x2, 0x2],
  }

  def draw_parent_info(img)
    feels = @weather[:feels_like] || 0
    time_str = Time.current.strftime("%-I:%M")
    info = "#{feels}Â° #{time_str}"

    # Use white text during countdown/fireworks for contrast against colored/black bg
    color = (countdown_progress || countdown_finished?) ? [255, 255, 255] : [136, 136, 136]
    draw_mini_text(img, info, 56, color)
  end

  def draw_mini_text(img, text, y, color)
    char_width = 4
    spacing = 1
    total_width = text.length * (char_width + spacing) - spacing
    x = (64 - total_width) / 2

    text.each_char do |char|
      draw_mini_char(img, char, x, y, color)
      x += char_width + spacing
    end
  end

  def draw_mini_char(img, char, x, y, color)
    bitmap = MINI_FONT[char]
    return unless bitmap

    bitmap.each_with_index do |row_bits, row|
      4.times do |col|
        if (row_bits >> (3 - col)) & 1 == 1
          px, py = x + col, y + row
          img.set_pixel(py, px, *color) if px >= 0 && px < 64 && py >= 0 && py < 64
        end
      end
    end
  end

  # --- Countdown background ---
  def countdown_start
    val = self.class.countdown_start
    val ? Time.zone.parse(val) : nil
  end

  def countdown_end
    val = self.class.countdown_end
    val ? Time.zone.parse(val) : nil
  end

  # For testing: override countdown progress (0.0 = just started, 1.0 = time's up)
  class << self
    attr_accessor :test_countdown_progress
  end

  def countdown_progress
    # Test mode override
    return self.class.test_countdown_progress if self.class.test_countdown_progress

    start_time = countdown_start
    end_time = countdown_end

    # Not configured
    return nil unless start_time && end_time

    now = Time.current

    # Outside countdown window
    return nil if now < start_time || now >= end_time

    # Calculate progress (0.0 = just started, 1.0 = time's up)
    total_duration = end_time - start_time
    elapsed = now - start_time
    total_duration > 0 ? (elapsed / total_duration).clamp(0, 1) : 1.0
  end

  def draw_countdown_background(img)
    # Fireworks celebration when countdown finishes
    if countdown_finished?
      draw_fireworks(img)
      return
    end

    progress = countdown_progress
    return unless progress

    # Color: green (0%) â†’ yellow (50%) â†’ red (100%)
    # HSV hue: 120 (green) â†’ 60 (yellow) â†’ 0 (red)
    hue = 120 * (1 - progress)
    r, g, b = hsv_to_rgb(hue, 0.85, 0.7)

    # Background drains right-to-left as time runs out
    # remaining_cols = how many columns are still colored (on the right side)
    remaining_cols = ((1 - progress) * 64).round
    start_col = 64 - remaining_cols  # Color starts here and goes to edge

    64.times do |y|
      64.times do |x|
        if x >= start_col
          img.set_pixel(y, x, r, g, b)
        else
          img.set_pixel(y, x, 0, 0, 0)  # Black = time's up for this column
        end
      end
    end
  end

  # Check if countdown just finished (within fireworks duration after end)
  def countdown_finished?
    return true if self.class.test_countdown_finished

    end_time = countdown_end
    return false unless end_time

    duration = parse_duration(self.class.fireworks_duration)
    now = Time.current
    now >= end_time && now < end_time + duration
  end

  # Parse duration string like "2m", "30s", "90s", "5m"
  def parse_duration(str)
    return 0 if str.nil? || str.empty? || str == "0"

    match = str.match(/^(\d+)(s|m)?$/i)
    return 2.minutes unless match  # Default fallback

    value = match[1].to_i
    unit = match[2]&.downcase || "s"

    case unit
    when "m" then value.minutes
    when "s" then value.seconds
    else value.seconds
    end
  end

  # For testing fireworks
  class << self
    attr_accessor :test_countdown_finished
  end

  def draw_fireworks(img)
    # Black background
    64.times do |y|
      64.times do |x|
        img.set_pixel(y, x, 0, 0, 0)
      end
    end

    # Animated firework bursts
    @firework_frame += 1

    # Multiple firework centers that cycle
    fireworks = [
      { cx: 32, cy: 20, color_offset: 0 },
      { cx: 15, cy: 30, color_offset: 40 },
      { cx: 50, cy: 25, color_offset: 80 },
      { cx: 32, cy: 45, color_offset: 120 },
    ]

    fireworks.each_with_index do |fw, i|
      # Each firework has its own phase
      phase = (@firework_frame + i * 15) % 60

      if phase < 40  # Burst expanding
        draw_firework_burst(img, fw[:cx], fw[:cy], phase, fw[:color_offset])
      end
      # else: pause before next burst
    end
  end

  def draw_firework_burst(img, cx, cy, phase, color_offset)
    # Burst expands from center
    radius = (phase * 0.8).round
    brightness = phase < 20 ? 1.0 : (1.0 - (phase - 20) / 20.0)  # Fade out

    # Draw particles in a circle
    num_particles = 16
    num_particles.times do |i|
      angle = (i * Math::PI * 2 / num_particles)

      # Particle position
      px = cx + (Math.cos(angle) * radius).round
      py = cy + (Math.sin(angle) * radius).round

      next unless px >= 0 && px < 64 && py >= 0 && py < 64

      # Red/orange tones for urgency
      hue = (color_offset + i * 5) % 40  # 0-40 = red to orange range
      r, g, b = hsv_to_rgb(hue, 1.0, brightness)

      img.set_pixel(py, px, r, g, b)

      # Sparkle trail
      if radius > 3
        trail_px = cx + (Math.cos(angle) * (radius - 2)).round
        trail_py = cy + (Math.sin(angle) * (radius - 2)).round
        if trail_px >= 0 && trail_px < 64 && trail_py >= 0 && trail_py < 64
          img.set_pixel(trail_py, trail_px, (r * 0.5).round, (g * 0.5).round, (b * 0.5).round)
        end
      end
    end
  end

  def hsv_to_rgb(h, s, v)
    c = v * s
    x = c * (1 - ((h / 60.0) % 2 - 1).abs)
    m = v - c

    r, g, b = case (h / 60).floor % 6
    when 0 then [c, x, 0]
    when 1 then [x, c, 0]
    when 2 then [0, c, x]
    when 3 then [0, x, c]
    when 4 then [x, 0, c]
    when 5 then [c, 0, x]
    end

    [(r + m) * 255, (g + m) * 255, (b + m) * 255].map(&:round)
  end

  # --- Emoji rendering ---
  def draw_emoji(img, emoji, x, y, size)
    codepoints = emoji.codepoints.reject { |cp| cp == 0xFE0F }.map { |cp| cp.to_s(16) }.join("-")
    cache_path = "/tmp/pixoo_twemoji_#{codepoints}_#{size}.png"

    unless File.exist?(cache_path)
      url = "https://cdn.jsdelivr.net/gh/twitter/twemoji@latest/assets/72x72/#{codepoints}.png"
      original_path = "/tmp/pixoo_twemoji_#{codepoints}_original.png"

      unless File.exist?(original_path)
        uri = URI(url)
        response = Net::HTTP.get_response(uri)
        if response.is_a?(Net::HTTPSuccess)
          File.binwrite(original_path, response.body)
        else
          puts "Failed to download emoji: #{emoji}"
          return
        end
      end

      image = MiniMagick::Image.open(original_path)
      image.resize "#{size}x#{size}"
      image.write cache_path
    end

    copy_png_to_buffer(img, cache_path, x, y)
  end

  def copy_png_to_buffer(img, png_path, offset_x, offset_y)
    return unless File.exist?(png_path)

    png = ChunkyPNG::Image.from_file(png_path)

    png.height.times do |dy|
      png.width.times do |dx|
        px = offset_x + dx
        py = offset_y + dy

        next unless px >= 0 && px < 64 && py >= 0 && py < 64

        pixel = png[dx, dy]
        a = ChunkyPNG::Color.a(pixel)
        next if a < 128

        r = ChunkyPNG::Color.r(pixel)
        g = ChunkyPNG::Color.g(pixel)
        b = ChunkyPNG::Color.b(pixel)

        img.set_pixel(py, px, r, g, b)
      end
    end
  end
end

# Clean exit on Ctrl+C
trap("INT") { puts; exit }

def generate_countdown_gif
  PixooDevice.require_imagemagick!
  gif_path = "/tmp/pixoo_weather_countdown.gif"

  puts "Generating countdown GIF..."

  display = WeatherDisplay.new(preview: true)
  pngs = []

  # 20 frames from 0% to 100%
  21.times do |i|
    progress = i / 20.0
    WeatherDisplay.test_countdown_progress = progress
    display.send(:refresh_weather_if_needed)
    display.send(:update_display)

    # Read the preview and add to pngs
    png = ChunkyPNG::Image.from_file(WeatherDisplay::PREVIEW_PATH)
    pngs << png
    print "."
  end
  puts

  WeatherDisplay.test_countdown_progress = nil

  # Save frames and create GIF
  tmp_dir = "/tmp/pixoo_weather_frames"
  FileUtils.mkdir_p(tmp_dir)
  FileUtils.rm_f(Dir.glob("#{tmp_dir}/*.png"))

  pngs.each_with_index do |png, i|
    png.save("#{tmp_dir}/frame_#{i.to_s.rjust(3, '0')}.png")
  end

  magick_cmd = PixooDevice.imagemagick_command
  system("#{magick_cmd} -delay 50 -loop 0 #{tmp_dir}/frame_*.png -scale 256x256 #{gif_path}")
  puts "Saved to: #{gif_path}"
end

def generate_fireworks_gif
  PixooDevice.require_imagemagick!
  gif_path = "/tmp/pixoo_weather_fireworks.gif"

  puts "Generating fireworks GIF..."

  display = WeatherDisplay.new(preview: true)
  WeatherDisplay.test_countdown_finished = true
  pngs = []

  # 60 frames of fireworks animation
  60.times do |i|
    display.send(:refresh_weather_if_needed)
    display.send(:update_display)

    png = ChunkyPNG::Image.from_file(WeatherDisplay::PREVIEW_PATH)
    pngs << png
    print "."
  end
  puts

  WeatherDisplay.test_countdown_finished = nil

  # Save frames and create GIF
  tmp_dir = "/tmp/pixoo_weather_frames"
  FileUtils.mkdir_p(tmp_dir)
  FileUtils.rm_f(Dir.glob("#{tmp_dir}/*.png"))

  pngs.each_with_index do |png, i|
    png.save("#{tmp_dir}/frame_#{i.to_s.rjust(3, '0')}.png")
  end

  magick_cmd = PixooDevice.imagemagick_command
  system("#{magick_cmd} -delay 10 -loop 0 #{tmp_dir}/frame_*.png -scale 256x256 #{gif_path}")
  puts "Saved to: #{gif_path}"
end

# Run it
if ARGV.include?("--list")
  PixooDevice.list_devices
elsif ARGV.include?("--help") || ARGV.include?("-h")
  puts "Usage: scripts/weather [OPTIONS]"
  puts
  puts "Options:"
  puts "  --list                   Discover and list all Pixoo devices"
  puts "  --preview                Render single frame to #{WeatherDisplay::PREVIEW_PATH}"
  puts "  --test-countdown=PCT     Preview at countdown progress (0-100)"
  puts "  --test-countdown-gif     Generate GIF showing full countdown"
  puts "  --test-fireworks-gif     Generate GIF of fireworks animation"
  puts "  --help                   Show this help message"
  puts
  puts "Environment variables:"
  puts "  LOCATION                    Location for weather (required)"
  puts "  WEATHER_DEVICE              Device name (optional if only one device)"
  puts "  WEATHER_COUNTDOWN_START     Countdown start time (e.g., 8:00am)"
  puts "  WEATHER_COUNTDOWN_END       Countdown end time (e.g., 8:20am)"
  puts "  WEATHER_FIREWORKS_DURATION  How long fireworks show after countdown (default: 2m)"
  puts
  puts "Examples:"
  puts "  scripts/weather --list"
  puts "  scripts/weather --preview"
  puts "  scripts/weather --test-countdown=50      # Preview at 50% (halfway, yellow)"
  puts "  scripts/weather --test-countdown-gif     # Countdown draining to black"
  puts "  scripts/weather --test-fireworks-gif     # Fireworks celebration"
  puts "  WEATHER_DEVICE=\"Kitchen\" scripts/weather"
elsif ARGV.include?("--test-countdown-gif")
  generate_countdown_gif
elsif ARGV.include?("--test-fireworks-gif")
  generate_fireworks_gif
elsif (countdown_arg = ARGV.find { |a| a.start_with?("--test-countdown=") })
  pct = countdown_arg.split("=")[1].to_f
  WeatherDisplay.test_countdown_progress = pct / 100.0
  display = WeatherDisplay.new(preview: true)
  display.send(:refresh_weather_if_needed)
  display.send(:update_display)
  puts "Preview at #{pct.round}% countdown saved to: #{WeatherDisplay::PREVIEW_PATH}"
  puts "Color drains right-to-left: green (0%) â†’ yellow (50%) â†’ red (100%) â†’ black"
elsif ARGV.include?("--preview")
  display = WeatherDisplay.new(preview: true)
  display.send(:refresh_weather_if_needed)
  display.send(:update_display)
  puts "Preview saved to: #{WeatherDisplay::PREVIEW_PATH}"
else
  WeatherDisplay.new(preview: false).run
end
