#!/usr/bin/env ruby
require_relative "../config/environment"
require_relative "../lib/pixoo_device"
require_relative "../lib/location"

class BedroomDisplay
  PREVIEW_PATH = "/tmp/pixoo_bedroom_preview.png"
  GIF_PATH = "/tmp/pixoo_bedroom.gif"

  # Night cycle times
  def self.sunset_start
    ENV.fetch("BEDROOM_SUNSET", "7:30pm")
  end

  def self.night_time
    ENV.fetch("BEDROOM_NIGHT", "8:00pm")
  end

  def self.sunrise_start
    ENV.fetch("BEDROOM_SUNRISE", "6:30am")
  end

  def self.day_time
    ENV.fetch("BEDROOM_DAY", "7:00am")
  end

  def self.resolve_device
    PixooDevice.resolve(ENV.fetch("BEDROOM_DEVICE", nil))
  rescue PixooDevice::AmbiguousDevice => e
    abort "BEDROOM_DEVICE not set.\n#{e.message}\nRun `scripts/bedroom --list` to see devices."
  end

  # For testing: override current time
  class << self
    attr_accessor :test_time
  end

  def initialize(preview: false)
    @preview = preview
    @frame = 0
    @stars = generate_stars(40)

    # Set timezone from location (required for correct time parsing)
    Location.setup_timezone!

    if @preview
      log "Preview mode: output to #{PREVIEW_PATH}"
    else
      @pixoo = self.class.resolve_device
      log "Bedroom display started (#{@pixoo.ip})"
      log "Sunset: #{self.class.sunset_start}→#{self.class.night_time}, Sunrise: #{self.class.sunrise_start}→#{self.class.day_time}"
      log "Ctrl+C to stop."
    end
  end

  def run
    if @preview
      # Single frame for preview mode
      update_display
      puts "Saved to: #{PREVIEW_PATH}"
    else
      # Continuous loop for device mode
      loop do
        update_display
        @frame += 1
        # No sleep - let send_animation pace the loop
      rescue => e
        log "Error: #{e.message}"
        sleep 5
      end
    end
  end

  # Run 24-hour cycle demo on device
  def run_demo(duration_seconds: 30)
    # Device takes ~300ms per frame, so use frame count directly
    frames = [duration_seconds * 3, 30].max  # ~3 FPS effective, min 30 frames
    start_time = Time.zone.parse(self.class.day_time)

    log "Running demo (#{frames} frames)..."

    frames.times do |i|
      simulated_minutes = (i.to_f / frames) * 24 * 60
      self.class.test_time = start_time + simulated_minutes.minutes

      @frame = i * 3  # Speed up animation
      intensity = night_intensity
      log "#{self.class.test_time.strftime('%I:%M%p')} intensity=#{intensity.round(2)}"

      update_display
      # No sleep - device send is already ~300ms
    end

    self.class.test_time = nil
    log "Demo complete!"
  end

  # Public: get current night intensity (for testing display)
  def current_intensity
    night_intensity
  end

  # Single source of truth for rendering a frame
  def render_frame
    img = Pixoo::ImageBuffer.new(64, speed: 100)
    intensity = night_intensity

    draw_sky(img, intensity)
    draw_stars(img, intensity) if intensity > 0.6
    draw_sun(img, intensity) if intensity <= 0.5
    draw_moon(img, intensity) if intensity >= 0.5
    draw_ground(img, intensity)

    img
  end

  # Public method for test GIF generation
  def render_frame_to_png
    img = render_frame

    png = ChunkyPNG::Image.new(64, 64, ChunkyPNG::Color::BLACK)
    64.times do |y|
      64.times do |x|
        r, g, b = img.get_pixel(y, x)
        png[x, y] = ChunkyPNG::Color.rgb(r, g, b)
      end
    end
    png
  end

  private

  def log(msg)
    puts "[#{Time.current.strftime('%H:%M:%S')}] #{msg}"
  end

  # Generate fixed star positions including heart constellation
  def generate_stars(count)
    stars = []

    # Heart constellation - smooth curves, no dents
    cx = 24  # Center x (away from moon on right)
    heart_points = [
      # Left bump top arc
      [cx-13, 14], [cx-12, 10], [cx-8, 8], [cx-4, 10],
      # Right bump top arc
      [cx+13, 14], [cx+12, 10], [cx+8, 8], [cx+4, 10],
      # Center dip
      [cx, 13],
      # Left side flowing down (continuous curve from bump)
      [cx-14, 18], [cx-14, 24], [cx-12, 30], [cx-8, 35],
      # Right side flowing down
      [cx+14, 18], [cx+14, 24], [cx+12, 30], [cx+8, 35],
      # Bottom point
      [cx-4, 39], [cx, 44], [cx+4, 39]
    ]

    heart_points.each_with_index do |point, i|
      stars << {
        x: point[0],
        y: point[1],
        size: 2,  # Brighter stars for constellation
        twinkle_offset: i * 8,
        constellation: true
      }
    end

    # Random background stars (avoid heart area)
    srand(12345)
    attempts = 0
    while stars.length < count + heart_points.length && attempts < count * 3
      attempts += 1
      x = rand(64)
      y = rand(45)  # Keep stars in upper sky

      # Skip if too close to heart constellation
      too_close = heart_points.any? { |hx, hy| (x - hx).abs < 4 && (y - hy).abs < 4 }
      next if too_close

      stars << {
        x: x,
        y: y,
        size: rand < 0.15 ? 2 : 1,
        twinkle_offset: rand(100),
        constellation: false
      }
    end

    stars
  end

  # Parse time string to today's Time object
  def parse_time(time_str)
    Time.zone.parse(time_str)
  end

  # Calculate night intensity (0 = full day, 1 = full night)
  def night_intensity
    now = self.class.test_time || Time.current

    # Convert all times to minutes since midnight
    now_mins = now.hour * 60 + now.min
    sunset_mins = parse_time(self.class.sunset_start).then { |t| t.hour * 60 + t.min }
    night_mins = parse_time(self.class.night_time).then { |t| t.hour * 60 + t.min }
    sunrise_mins = parse_time(self.class.sunrise_start).then { |t| t.hour * 60 + t.min }
    day_mins = parse_time(self.class.day_time).then { |t| t.hour * 60 + t.min }

    sunset_duration = night_mins - sunset_mins
    sunset_duration += 24 * 60 if sunset_duration < 0  # Handle midnight crossing

    sunrise_duration = day_mins - sunrise_mins
    sunrise_duration += 24 * 60 if sunrise_duration < 0  # Handle midnight crossing

    # Helper to check if time is in a window (handles midnight crossing)
    in_window = ->(start_m, end_m) {
      if end_m > start_m
        now_mins >= start_m && now_mins < end_m
      else
        # Window crosses midnight
        now_mins >= start_m || now_mins < end_m
      end
    }

    # Check each phase
    if in_window.call(sunset_mins, night_mins)
      # Sunset: fading to night
      if now_mins >= sunset_mins
        (now_mins - sunset_mins).to_f / sunset_duration
      else
        # After midnight in a sunset that crosses midnight
        (now_mins + 24 * 60 - sunset_mins).to_f / sunset_duration
      end
    elsif in_window.call(sunrise_mins, day_mins)
      # Sunrise: fading to day
      if now_mins >= sunrise_mins
        1.0 - (now_mins - sunrise_mins).to_f / sunrise_duration
      else
        # After midnight in a sunrise that crosses midnight
        1.0 - (now_mins + 24 * 60 - sunrise_mins).to_f / sunrise_duration
      end
    elsif in_window.call(night_mins, sunrise_mins)
      # Full night
      1.0
    else
      # Full day
      0.0
    end
  end

  def update_display
    t0 = Time.now
    img = render_frame  # Single source of truth
    render_time = Time.now - t0

    if @preview
      save_preview(img)
    else
      t1 = Time.now
      @pixoo.send_animation([img])
      send_time = Time.now - t1
      log "render=#{(render_time * 1000).round}ms send=#{(send_time * 1000).round}ms" if @frame % 10 == 0
    end
  end

  def draw_sky(img, intensity)
    54.times do |y|
      # How close to horizon (0 = top, 1 = horizon)
      horizon_factor = y / 54.0

      # Base day/night sky colors
      day_top = [100, 160, 255]      # Blue sky at top
      day_horizon = [170, 200, 255]  # Lighter blue at horizon
      night_top = [10, 15, 40]       # Dark blue at top
      night_horizon = [20, 25, 50]   # Slightly lighter at horizon

      # Sunset/sunrise colors (orange/pink at horizon)
      sunset_top = [80, 60, 120]      # Purple-ish
      sunset_horizon = [255, 120, 50] # Orange

      # Calculate transition factor (peaks at 0.5)
      # 0.0 = full day/night, 1.0 = peak sunset/sunrise colors
      transition = 0.0
      if intensity >= 0.2 && intensity <= 0.5
        transition = ((intensity - 0.2) / 0.3).clamp(0, 1)  # Sunset
      elsif intensity >= 0.5 && intensity <= 0.8
        transition = ((0.8 - intensity) / 0.3).clamp(0, 1)  # Sunrise
      end

      # Blend colors based on intensity
      if intensity <= 0.5
        # Day to sunset
        night_blend = (intensity / 0.5).clamp(0, 1)
        top = blend_colors(day_top, sunset_top, night_blend * transition)
        horiz = blend_colors(day_horizon, sunset_horizon, transition)
      else
        # Night to sunrise
        day_blend = ((intensity - 0.5) / 0.5).clamp(0, 1)
        # Blend toward night: day_blend for depth, (1-transition) keeps sunset during transition
        night_factor = (day_blend + (1 - transition) * (1 - day_blend)).clamp(0, 1)
        top = blend_colors(sunset_top, night_top, night_factor)
        horiz = blend_colors(sunset_horizon, night_horizon, 1 - transition)
      end

      # Interpolate between top and horizon for this row
      r = lerp(top[0], horiz[0], horizon_factor).round.clamp(0, 255)
      g = lerp(top[1], horiz[1], horizon_factor).round.clamp(0, 255)
      b = lerp(top[2], horiz[2], horizon_factor).round.clamp(0, 255)

      64.times { |x| img.set_pixel(y, x, r, g, b) }
    end
  end

  def blend_colors(c1, c2, t)
    [
      lerp(c1[0], c2[0], t),
      lerp(c1[1], c2[1], t),
      lerp(c1[2], c2[2], t)
    ]
  end

  def draw_stars(img, intensity)
    # Stars fade in as it gets darker (intensity 0.6 -> 1.0)
    star_alpha = ((intensity - 0.6) / 0.4).clamp(0, 1)

    @stars.each do |star|
      next if star[:y] >= 54  # Don't draw on ground

      # Twinkle effect - constellation stars sparkle more
      if star[:constellation]
        # Sparkle: periodic bright flashes
        sparkle = Math.sin((@frame + star[:twinkle_offset]) * 0.25)
        sparkle_boost = sparkle > 0.7 ? (sparkle - 0.7) / 0.3 : 0
        twinkle = 0.7 + sparkle * 0.3 + sparkle_boost * 0.5
        alpha = (star_alpha * twinkle).clamp(0, 1)
        brightness = (255 * alpha).round
      else
        twinkle = Math.sin((@frame + star[:twinkle_offset]) * 0.15) * 0.3 + 0.7
        alpha = (star_alpha * twinkle).clamp(0, 1)
        brightness = (160 * alpha).round
      end

      next if alpha < 0.1

      # Draw star (additive blend with sky)
      r, g, b = img.get_pixel(star[:y], star[:x])
      new_r = [r + brightness, 255].min
      new_g = [g + brightness, 255].min
      new_b = [b + (brightness * 0.85).round, 255].min
      img.set_pixel(star[:y], star[:x], new_r, new_g, new_b)

      # Constellation stars get sparkle glow
      if star[:constellation] && alpha > 0.6
        glow_size = alpha > 0.9 ? 2 : 1  # Bigger glow when sparkling
        (-glow_size..glow_size).each do |dx|
          (-glow_size..glow_size).each do |dy|
            next if dx == 0 && dy == 0
            dist = Math.sqrt(dx*dx + dy*dy)
            next if dist > glow_size
            nx, ny = star[:x] + dx, star[:y] + dy
            next if nx < 0 || nx >= 64 || ny < 0 || ny >= 54
            sr, sg, sb = img.get_pixel(ny, nx)
            glow = (brightness * 0.35 * (1 - dist/glow_size/1.5)).round
            img.set_pixel(ny, nx, [sr + glow, 255].min, [sg + glow, 255].min, [sb + (glow * 0.8).round, 255].min)
          end
        end
      end
    end
  end

  def draw_moon(img, intensity)
    # Moon rises as intensity goes from 0.5 to 0.8
    moon_progress = ((intensity - 0.5) / 0.3).clamp(0, 1)

    # Moon position - rises from right horizon to upper right
    cx = 50
    cy = (50 - moon_progress * 38).round  # Rise from y=50 to y=12
    radius = 7

    return if cy > 50  # Below horizon

    # Draw moon circle
    (-radius..radius).each do |dy|
      (-radius..radius).each do |dx|
        dist = Math.sqrt(dx * dx + dy * dy)
        if dist <= radius
          x, y = cx + dx, cy + dy
          next if x < 0 || x >= 64 || y < 0 || y >= 54

          # Soft edge
          edge_fade = dist > radius - 1.5 ? (radius - dist) / 1.5 : 1.0
          edge_fade = edge_fade.clamp(0, 1)

          # Moon color (pale yellow-white), blended with sky
          sky_r, sky_g, sky_b = img.get_pixel(y, x)
          moon_brightness = edge_fade * moon_progress

          r = lerp(sky_r, 230, moon_brightness).round
          g = lerp(sky_g, 225, moon_brightness).round
          b = lerp(sky_b, 200, moon_brightness).round
          img.set_pixel(y, x, r, g, b)
        end
      end
    end

    # Subtle craters when fully visible
    if moon_progress > 0.8
      crater_alpha = (moon_progress - 0.8) / 0.2
      [[cx - 2, cy], [cx + 2, cy + 2], [cx, cy + 3]].each do |x, y|
        next if x < 0 || x >= 64 || y < 0 || y >= 54
        r, g, b = img.get_pixel(y, x)
        img.set_pixel(y, x,
          (r * (1 - 0.15 * crater_alpha)).round,
          (g * (1 - 0.15 * crater_alpha)).round,
          (b * (1 - 0.15 * crater_alpha)).round
        )
      end
    end
  end

  def draw_sun(img, intensity)
    # intensity 0 = full day (sun high), 0.5 = sunset (sun at horizon)
    # Sun should be HIGH when intensity is LOW
    sun_progress = (intensity / 0.5).clamp(0, 1)  # 0 = high noon, 1 = horizon

    # Sun position - high in sky at noon, drops to horizon at sunset
    base_x = 20
    base_y = (15 + sun_progress * 33).round  # Range from y=15 (high) to y=48 (horizon)
    radius = 9

    return if base_y > 52  # Below horizon

    # Sun glow on horizon during sunset (intensity 0.3-0.5)
    if intensity > 0.25 && base_y > 30
      glow_intensity = ((intensity - 0.25) / 0.25).clamp(0, 1)
      draw_sun_glow(img, base_x, glow_intensity)
    end

    # Draw sun core
    (-radius..radius).each do |dy|
      (-radius..radius).each do |dx|
        dist = Math.sqrt(dx * dx + dy * dy)
        if dist <= radius
          x, y = base_x + dx, base_y + dy
          next if x < 0 || x >= 64 || y < 0 || y >= 54

          edge_fade = dist > radius - 1.5 ? (radius - dist) / 1.5 : 1.0
          edge_fade = edge_fade.clamp(0, 1)

          # Blend sun with sky color
          sky_r, sky_g, sky_b = img.get_pixel(y, x)
          r = lerp(sky_r, 255, edge_fade).round
          g = lerp(sky_g, 240, edge_fade).round
          b = lerp(sky_b, 100, edge_fade).round
          img.set_pixel(y, x, r, g, b)
        end
      end
    end

    # Sun rays when high in sky (sun_progress < 0.5 means sun is high)
    if sun_progress < 0.5
      ray_alpha = 1.0 - (sun_progress / 0.5)
      draw_sun_rays(img, base_x, base_y, radius, ray_alpha)
    end
  end

  def draw_sun_glow(img, sun_x, glow_intensity)
    # Orange glow on horizon
    (45..53).each do |y|
      64.times do |x|
        dist_from_sun = (x - sun_x).abs
        glow = (1.0 - dist_from_sun / 30.0).clamp(0, 1) * glow_intensity * (54 - y) / 9.0
        next if glow < 0.05

        r, g, b = img.get_pixel(y, x)
        img.set_pixel(y, x,
          [r + (80 * glow).round, 255].min,
          [g + (40 * glow).round, 255].min,
          b
        )
      end
    end
  end

  def draw_sun_rays(img, cx, cy, radius, alpha)
    ray_count = 8
    ray_length = (4 + Math.sin(@frame * 0.1) * 2).round

    ray_count.times do |i|
      angle = (i * Math::PI * 2 / ray_count) + (@frame * 0.02)

      ray_length.times do |r|
        dist = radius + 1 + r
        x = cx + (Math.cos(angle) * dist).round
        y = cy + (Math.sin(angle) * dist).round

        next if x < 0 || x >= 64 || y < 0 || y >= 54

        ray_fade = (1 - r.to_f / ray_length) * alpha
        sky_r, sky_g, sky_b = img.get_pixel(y, x)

        img.set_pixel(y, x,
          lerp(sky_r, 255, ray_fade * 0.5).round,
          lerp(sky_g, 230, ray_fade * 0.5).round,
          lerp(sky_b, 120, ray_fade * 0.3).round
        )
      end
    end
  end

  def draw_ground(img, night)
    # Ground color transitions from green (day) to dark (night)
    day_colors = [[34, 139, 34], [45, 160, 45]]  # Forest green
    night_colors = [[10, 40, 10], [15, 50, 15]]  # Dark green

    (54...64).each do |y|
      row_idx = y - 54
      day_c = day_colors[[row_idx / 5, 1].min]
      night_c = night_colors[[row_idx / 5, 1].min]

      r = lerp(day_c[0], night_c[0], night).round
      g = lerp(day_c[1], night_c[1], night).round
      b = lerp(day_c[2], night_c[2], night).round

      64.times do |x|
        img.set_pixel(y, x, r, g, b)
      end
    end
  end

  def lerp(a, b, t)
    a + (b - a) * t
  end

  def save_preview(img)
    png = ChunkyPNG::Image.new(64, 64, ChunkyPNG::Color::BLACK)

    64.times do |y|
      64.times do |x|
        r, g, b = img.get_pixel(y, x)
        png[x, y] = ChunkyPNG::Color.rgb(r, g, b)
      end
    end

    png.save(PREVIEW_PATH)
  end

  def self.generate_test_gif(time_arg, frames: 30)
    case time_arg
    when "cycle"
      generate_cycle_gif
    when "transitions"
      generate_transitions_gif
    else
      generate_static_time_gif(time_arg, frames: frames)
    end
  end

  def self.generate_cycle_gif
    # 120 frames covering 24 hours, 50cs delay each = 60 second GIF
    frames = 120
    delay = 50  # centiseconds (0.5s per frame)

    puts "Generating 24-hour cycle GIF (#{frames} frames, 60 seconds playback)"
    puts "Sunset: #{sunset_start}→#{night_time}, Sunrise: #{sunrise_start}→#{day_time}"

    display = new(preview: true)
    pngs = []

    # Start from day time and go through full 24 hours
    start_time = Time.zone.parse(day_time)

    frames.times do |i|
      # Each frame = 12 minutes of simulated time (24h / 120 frames)
      self.test_time = start_time + (i * 12).minutes
      display.instance_variable_set(:@frame, i)
      pngs << display.render_frame_to_png
      print "."
    end
    puts

    save_gif(pngs, delay: delay)
    puts "Saved to: #{GIF_PATH}"
  end

  def self.generate_transitions_gif
    # Focus on transitions: day → sunset → night → sunrise → day
    # 20 frames per transition, 5 frames for day/night holds
    frames_per_transition = 20
    frames_hold = 5
    delay = 20  # centiseconds (0.2s per frame)

    puts "Generating transitions GIF (focused on sunset/sunrise)"
    puts "Sunset: #{sunset_start}→#{night_time}, Sunrise: #{sunrise_start}→#{day_time}"

    display = new(preview: true)
    pngs = []
    frame_num = 0

    sunset_start_time = Time.zone.parse(sunset_start)
    night_start_time = Time.zone.parse(night_time)
    sunrise_start_time = Time.zone.parse(sunrise_start)
    day_start_time = Time.zone.parse(day_time)

    # Calculate durations
    sunset_duration = (night_start_time - sunset_start_time) / 60.0  # minutes
    sunset_duration += 24 * 60 if sunset_duration < 0
    sunrise_duration = (day_start_time - sunrise_start_time) / 60.0  # minutes
    sunrise_duration += 24 * 60 if sunrise_duration < 0

    # 1. Day hold (before sunset)
    frames_hold.times do |i|
      self.test_time = sunset_start_time - 10.minutes
      display.instance_variable_set(:@frame, frame_num)
      pngs << display.render_frame_to_png
      frame_num += 1
      print "."
    end

    # 2. Sunset transition
    frames_per_transition.times do |i|
      progress = i.to_f / (frames_per_transition - 1)
      self.test_time = sunset_start_time + (progress * sunset_duration).minutes
      display.instance_variable_set(:@frame, frame_num)
      pngs << display.render_frame_to_png
      frame_num += 1
      print "."
    end

    # 3. Night hold
    frames_hold.times do |i|
      self.test_time = night_start_time + 30.minutes
      display.instance_variable_set(:@frame, frame_num)
      pngs << display.render_frame_to_png
      frame_num += 1
      print "."
    end

    # 4. Sunrise transition
    frames_per_transition.times do |i|
      progress = i.to_f / (frames_per_transition - 1)
      self.test_time = sunrise_start_time + (progress * sunrise_duration).minutes
      display.instance_variable_set(:@frame, frame_num)
      pngs << display.render_frame_to_png
      frame_num += 1
      print "."
    end

    # 5. Day hold (after sunrise)
    frames_hold.times do |i|
      self.test_time = day_start_time + 10.minutes
      display.instance_variable_set(:@frame, frame_num)
      pngs << display.render_frame_to_png
      frame_num += 1
      print "."
    end

    puts
    puts "Total frames: #{pngs.length}"

    save_gif(pngs, delay: delay)
    puts "Saved to: #{GIF_PATH}"
  end

  def self.generate_static_time_gif(time_arg, frames: 30)
    # Parse time argument
    test_time = case time_arg
    when "day", "daytime"
      Time.zone.parse("12:00pm")
    when "night", "nighttime"
      Time.zone.parse("2:00am")
    when "sunset"
      Time.zone.parse(sunset_start)
    when "sunrise"
      Time.zone.parse(sunrise_start)
    when "wake", "wakeup"
      Time.zone.parse(day_time)
    else
      Time.zone.parse(time_arg)
    end

    puts "Generating #{frames}-frame GIF at simulated time: #{test_time.strftime('%I:%M %p')}"
    puts "Sunset: #{sunset_start}→#{night_time}, Sunrise: #{sunrise_start}→#{day_time}"

    display = new(preview: true)
    pngs = []

    frames.times do |i|
      self.test_time = test_time
      display.instance_variable_set(:@frame, i)
      pngs << display.render_frame_to_png
      print "."
    end
    puts

    save_gif(pngs, delay: 10)
    puts "Saved to: #{GIF_PATH}"
    puts "Intensity at this time: #{display.current_intensity.round(2)} (0=day, 1=night)"
  end

  def self.save_gif(pngs, delay: 10)
    PixooDevice.require_imagemagick!

    tmp_dir = "/tmp/pixoo_bedroom_frames"
    FileUtils.mkdir_p(tmp_dir)
    FileUtils.rm_f(Dir.glob("#{tmp_dir}/*.png"))

    pngs.each_with_index do |png, i|
      png.save("#{tmp_dir}/frame_#{i.to_s.rjust(3, '0')}.png")
    end

    magick_cmd = PixooDevice.imagemagick_command
    system("#{magick_cmd} -delay #{delay} -loop 0 #{tmp_dir}/frame_*.png -scale 256x256 #{GIF_PATH}")
  end
end

# Clean exit on Ctrl+C
trap("INT") { puts; exit }

# Run it
if ARGV.include?("--list")
  PixooDevice.list_devices
elsif ARGV.include?("--help") || ARGV.include?("-h")
  puts "Usage: scripts/bedroom [OPTIONS]"
  puts
  puts "Displays an animated day/night cycle for bedroom sleep schedules."
  puts
  puts "Options:"
  puts "  --list             Discover and list all Pixoo devices on the network"
  puts "  --demo[=SECONDS]   Run 24-hour cycle on device (default: 30 seconds)"
  puts "  --preview          Render single frame to #{BedroomDisplay::PREVIEW_PATH}"
  puts "  --test-gif=TIME    Generate animated GIF at simulated time"
  puts "  --help             Show this help message"
  puts
  puts "TIME can be:"
  puts "  transitions        Focused on sunset/sunrise (recommended)"
  puts "  cycle              Full 24-hour cycle (sparse transitions)"
  puts "  night, day         Full night or day"
  puts "  sunset, sunrise    At start of transition"
  puts "  9:30pm             Specific time"
  puts
  puts "Environment variables:"
  puts "  BEDROOM_DEVICE   Device name (optional if only one device)"
  puts "  BEDROOM_SUNSET   When sunset starts (default: 7:30pm)"
  puts "  BEDROOM_NIGHT    When fully night (default: 8:00pm)"
  puts "  BEDROOM_SUNRISE  When sunrise starts (default: 6:30am)"
  puts "  BEDROOM_DAY      When fully day (default: 7:00am)"
  puts
  puts "Examples:"
  puts "  scripts/bedroom --list              # Find devices"
  puts "  scripts/bedroom --demo               # 30s demo cycle on device"
  puts "  scripts/bedroom --demo=60            # 60s demo cycle on device"
  puts "  scripts/bedroom --test-gif=cycle     # Generate 24-hour GIF"
  puts "  BEDROOM_DEVICE=\"Bedroom\" scripts/bedroom"
elsif (demo_arg = ARGV.find { |a| a.start_with?("--demo") })
  duration = (demo_arg.split("=")[1] || "30").to_i
  BedroomDisplay.new(preview: false).run_demo(duration_seconds: duration)
elsif (test_arg = ARGV.find { |a| a.start_with?("--test-gif") })
  time_val = test_arg.split("=")[1] || "night"
  BedroomDisplay.generate_test_gif(time_val)
else
  preview_mode = ARGV.include?("--preview")
  BedroomDisplay.new(preview: preview_mode).run
end
